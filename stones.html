<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ワンオラクル（さざれ石）- ジオマンシー占い</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Hiragino Sans', 'Noto Sans JP', sans-serif;
            background: linear-gradient(135deg, #e8dcc6 0%, #d4c4a8 100%);
            min-height: 100vh;
            color: #5d4e37;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: none;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .back-button {
            background: none;
            border: none;
            color: #5d4e37;
            padding: 16px 20px;
            font-size: 16px;
            cursor: pointer;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            text-decoration: none;
            display: block;
            text-align: left;
        }

        .back-button:hover {
            color: #8b7355;
        }

        .canvas-container {
            width: 100%;
            aspect-ratio: 1;
            max-width: 600px;
            margin: 0 auto;
            position: relative;
            background: rgba(255,255,255,0.3);
            border-radius: 12px;
            touch-action: none;
        }

        #stones-canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            border-radius: 12px;
        }

        .dice-results {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin: 20px 0;
            padding: 0 20px;
        }

        .dice-result-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .dice-result-box {
            background: rgba(255,255,255,0.9);
            border-radius: 8px;
            padding: 12px;
            width: 60px;
            height: 60px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 2px solid transparent;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .dice-result-box.fire {
            border-color: #ffaaaa;
            background: #ffdddd;
        }

        .dice-result-box.air {
            border-color: #ffffaa;
            background: #ffffdd;
        }

        .dice-result-box.water {
            border-color: #aaccff;
            background: #ddeeff;
        }

        .dice-result-box.earth {
            border-color: #aaffaa;
            background: #ddffdd;
        }

        .element-label {
            font-size: 11px;
            color: rgba(93,78,55,0.8);
            font-weight: 600;
        }

        .dice-value {
            font-size: 20px;
            font-weight: bold;
            color: #5d4e37;
        }

        .dice-value.empty {
            color: rgba(93,78,55,0.3);
            font-size: 16px;
        }

        .symbol-slots {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin: 20px 0;
            padding: 0 20px;
        }

        .symbol-slot {
            background: rgba(255,255,255,0.5);
            border: 2px solid rgba(139,115,85,0.3);
            border-radius: 8px;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .symbol-slot img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        @media (max-width: 480px) {
            .container {
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <button class="back-button" onclick="goBack()">← 戻る</button>
        
        <div style="flex: 1; display: flex; flex-direction: column;">
            <div class="canvas-container">
                <canvas id="stones-canvas"></canvas>
            </div>
            
            <div style="padding: 16px 20px 20px 20px; text-align: center;">
                <p style="color: rgba(93,78,55,0.7); font-size: 14px; margin-bottom: 16px; line-height: 1.4;" id="instruction-text">
                    どんなことを占いたいのかを強く心に思いながら、画面上のさざれ石を指でなぞって囲んでください。閉じた線を4回描くことで、ジオマンシーのシンボルが決まります。囲んだ石の数が偶数か奇数かで判定されます。
                </p>
                
                <div class="dice-results">
                    <div class="dice-result-container">
                        <div class="dice-result-box fire">
                            <span class="dice-value empty" id="result-fire">-</span>
                        </div>
                        <span class="element-label">火</span>
                    </div>
                    <div class="dice-result-container">
                        <div class="dice-result-box air">
                            <span class="dice-value empty" id="result-air">-</span>
                        </div>
                        <span class="element-label">風</span>
                    </div>
                    <div class="dice-result-container">
                        <div class="dice-result-box water">
                            <span class="dice-value empty" id="result-water">-</span>
                        </div>
                        <span class="element-label">水</span>
                    </div>
                    <div class="dice-result-container">
                        <div class="dice-result-box earth">
                            <span class="dice-value empty" id="result-earth">-</span>
                        </div>
                        <span class="element-label">地</span>
                    </div>
                </div>
                
                <!-- シールドチャート用のシンボル表示欄 -->
                <div class="symbol-slots" id="symbol-slots" style="display: none;">
                    <div class="symbol-slot" id="symbol-slot-0"></div>
                    <div class="symbol-slot" id="symbol-slot-1"></div>
                    <div class="symbol-slot" id="symbol-slot-2"></div>
                    <div class="symbol-slot" id="symbol-slot-3"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // URLパラメータからモードを取得
        const urlParams = new URLSearchParams(window.location.search);
        const mode = urlParams.get('mode') || 'oneoracle';
        const isShieldMode = mode === 'shield';
        
        const canvas = document.getElementById('stones-canvas');
        const ctx = canvas.getContext('2d');
        
        let stones = [];
        let currentPath = [];
        let isDrawing = false;
        let completedRounds = [];
        let currentRoundResult = null;
        
        // シールドチャート用の変数
        let completedSymbols = []; // 確定したシンボルの配列
        let currentSymbolIndex = 0; // 現在生成中のシンボル（0-3）
        
        const STONE_RADIUS = 4;
        const STONE_COUNT = 50;
        const CLOSE_THRESHOLD = 30;
        const MIN_PATH_LENGTH = 20;

        const geomancySymbols = {
            '2222': { name: 'Populus（人々）', meaning: '物事や人が多数ある状態。受け身。安定。', yesno: 'イエス', fortune: '吉' },
            '1111': { name: 'Via（道）', meaning: '変化、動くこと、過程。決断。積極性、能動性。', yesno: 'ノー', fortune: '吉でも凶でもない。旅や移動について吉' },
            '2112': { name: 'Conjunctio（つながり）', meaning: '違う者同士結びつく、目的を持って集まる、縁が生まれる。失せ物が見つかる。', yesno: 'イエス', fortune: '吉と凶の両方' },
            '1221': { name: 'Carcer（拘束）', meaning: '孤独、身動きが取れない、ひきこもり。困滞、現状維持。', yesno: 'ノー', fortune: '凶。セキュリティに関しては吉' },
            '2211': { name: 'Fortuna Major（大吉）', meaning: '大きな幸運。自分の思い通りにことが運ぶ。', yesno: 'イエス', fortune: '大吉' },
            '1122': { name: 'Fortuna Minor（小吉）', meaning: '小さく一時的な幸運、ささやかな幸せ。周りからの援助。', yesno: 'イエス', fortune: '小吉' },
            '2121': { name: 'Acquisitio（獲得）', meaning: '収穫、利益。願いが叶う。何かを受け取る、受け入れる。', yesno: 'イエス', fortune: '吉' },
            '1212': { name: 'Amissio（喪失）', meaning: '損失、愛情や金銭などを失う。病気やトラブル、悪癖がなくなる。', yesno: 'ノー', fortune: '凶' },
            '1222': { name: 'Laetitia（喜び）', meaning: '喜ばしいこと、笑い、成功。音楽や踊り。髭のある男性。', yesno: 'イエス', fortune: '吉' },
            '2221': { name: 'Tristitia（悲しみ）', meaning: '不幸、受難、宿命。', yesno: 'ノー', fortune: '凶。占いや魔術に関しては吉' },
            '1211': { name: 'Puella（少女）', meaning: '女性らしさ、美しさ。ときめき、嬉しさ。目先の楽しみ。', yesno: 'イエス', fortune: '吉' },
            '1121': { name: 'Puer（少年）', meaning: '男性らしさ、力強さ、未熟さ。未来を切り開く。', yesno: 'ノー', fortune: '凶。争い事には吉' },
            '2212': { name: 'Albus（白）', meaning: '公正、高潔さ、正義。片思いやプラトニック・ラブ。', yesno: 'イエス', fortune: '吉' },
            '2122': { name: 'Rubeus（赤）', meaning: '争い事、闘争心。悪いことには吉、良いことには凶。', yesno: 'ノー', fortune: '凶' },
            '2111': { name: 'Caput Draconis（竜の頭）', meaning: '始まり、新しい扉が開く、前例のない課題に取り組む。やりすぎの傾向。', yesno: 'イエス', fortune: '吉凶入り混じる。何かを始めるには吉' },
            '1112': { name: 'Cauda Draconis（竜の尾）', meaning: '終わり、物事の完成、途絶。吉は凶となり、凶は吉となる。', yesno: 'ノー', fortune: '吉でも凶でもない。何かを終わらせるには吉' }
        };

        function goBack() {
            window.history.back();
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        function initStones() {
            stones = [];
            const MIN_DISTANCE = STONE_RADIUS * 5;
            const EDGE_MARGIN = 20;
            const MAX_ATTEMPTS = 50;
            
            for (let i = 0; i < STONE_COUNT; i++) {
                let attempts = 0;
                let newStone = null;
                let validPosition = false;
                
                while (!validPosition && attempts < MAX_ATTEMPTS) {
                    newStone = {
                        x: EDGE_MARGIN + Math.random() * (canvas.width - EDGE_MARGIN * 2),
                        y: EDGE_MARGIN + Math.random() * (canvas.height - EDGE_MARGIN * 2)
                    };
                    
                    validPosition = true;
                    for (let j = 0; j < stones.length; j++) {
                        const distance = Math.hypot(newStone.x - stones[j].x, newStone.y - stones[j].y);
                        if (distance < MIN_DISTANCE) {
                            validPosition = false;
                            break;
                        }
                    }
                    
                    attempts++;
                }
                
                if (newStone) {
                    stones.push(newStone);
                }
            }
        }

        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            stones.forEach(stone => {
                ctx.fillStyle = '#8b7355';
                ctx.beginPath();
                ctx.arc(stone.x, stone.y, STONE_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            });
            
            if (currentPath.length > 0) {
                ctx.strokeStyle = '#5d4e37';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(currentPath[0].x, currentPath[0].y);
                for (let i = 1; i < currentPath.length; i++) {
                    ctx.lineTo(currentPath[i].x, currentPath[i].y);
                }
                ctx.stroke();
                
                if (currentPath.length > MIN_PATH_LENGTH) {
                    const startPoint = currentPath[0];
                    const endPoint = currentPath[currentPath.length - 1];
                    const distance = Math.hypot(endPoint.x - startPoint.x, endPoint.y - startPoint.y);
                    
                    if (distance < CLOSE_THRESHOLD) {
                        ctx.fillStyle = 'rgba(139,115,85,0.08)';
                        ctx.beginPath();
                        ctx.moveTo(currentPath[0].x, currentPath[0].y);
                        for (let i = 1; i < currentPath.length; i++) {
                            ctx.lineTo(currentPath[i].x, currentPath[i].y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.strokeStyle = 'rgba(139,115,85,0.5)';
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(endPoint.x, endPoint.y);
                        ctx.lineTo(startPoint.x, startPoint.y);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
            }
            
            if (currentRoundResult && currentRoundResult.path) {
                const path = currentRoundResult.path;
                
                ctx.fillStyle = 'rgba(139,115,85,0.15)';
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x, path[i].y);
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = '#8b7355';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }

        function startDrawing(e) {
            e.preventDefault();
            isDrawing = true;
            const pos = getPointerPos(e);
            currentPath = [pos];
            currentRoundResult = null;
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            
            const pos = getPointerPos(e);
            currentPath.push(pos);
            
            if (currentPath.length > MIN_PATH_LENGTH) {
                const intersection = checkLastSegmentIntersection(currentPath);
                
                if (intersection.intersects) {
                    const newPath = [];
                    newPath.push(intersection.point);
                    
                    for (let i = intersection.index1 + 1; i <= intersection.index2; i++) {
                        newPath.push(currentPath[i]);
                    }
                    
                    newPath.push(intersection.point);
                    
                    currentPath = newPath;
                    isDrawing = false;
                    countEnclosedStones();
                    return;
                }
            }
            
            redraw();
        }

        function checkLastSegmentIntersection(path) {
            const lastIndex = path.length - 1;
            if (lastIndex < 3) return { intersects: false };
            
            const lastSegmentStart = path[lastIndex - 1];
            const lastSegmentEnd = path[lastIndex];
            
            for (let i = 0; i < lastIndex - 2; i++) {
                if (lineSegmentsIntersect(
                    lastSegmentStart, lastSegmentEnd,
                    path[i], path[i + 1]
                )) {
                    const intersectionPoint = getIntersectionPoint(
                        lastSegmentStart, lastSegmentEnd,
                        path[i], path[i + 1]
                    );
                    return {
                        intersects: true,
                        index1: i,
                        index2: lastIndex - 1,
                        point: intersectionPoint
                    };
                }
            }
            
            return { intersects: false };
        }

        function lineSegmentsIntersect(p1, p2, p3, p4) {
            const ccw = (A, B, C) => {
                return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);
            };
            return ccw(p1, p3, p4) !== ccw(p2, p3, p4) && ccw(p1, p2, p3) !== ccw(p1, p2, p4);
        }

        function getIntersectionPoint(p1, p2, p3, p4) {
            const x1 = p1.x, y1 = p1.y;
            const x2 = p2.x, y2 = p2.y;
            const x3 = p3.x, y3 = p3.y;
            const x4 = p4.x, y4 = p4.y;
            
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 0.0001) return null;
            
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            
            return {
                x: x1 + t * (x2 - x1),
                y: y1 + t * (y2 - y1)
            };
        }

        function endDrawing(e) {
            if (!isDrawing) return;
            e.preventDefault();
            isDrawing = false;
            
            if (currentPath.length > MIN_PATH_LENGTH) {
                const startPoint = currentPath[0];
                const endPoint = currentPath[currentPath.length - 1];
                const distance = Math.hypot(endPoint.x - startPoint.x, endPoint.y - startPoint.y);
                
                if (distance < CLOSE_THRESHOLD) {
                    currentPath.push(startPoint);
                    countEnclosedStones();
                } else {
                    currentPath = [];
                    redraw();
                }
            } else {
                currentPath = [];
                redraw();
            }
        }

        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                
                const intersect = ((yi > point.y) !== (yj > point.y))
                    && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function countEnclosedStones() {
            const enclosedStones = stones.filter(stone => isPointInPolygon(stone, currentPath));
            const count = enclosedStones.length;
            
            if (count === 0) {
                currentPath = [];
                currentRoundResult = null;
                redraw();
                return;
            }
            
            const parity = count % 2 === 0 ? 2 : 1;
            
            currentRoundResult = {
                path: [...currentPath],
                count: count,
                parity: parity,
                enclosedStones: enclosedStones
            };
            
            completedRounds.push(parity);
            
            redraw();
            
            animatePairing(enclosedStones, () => {
                updateResults();
                
                if (completedRounds.length === 4) {
                    setTimeout(() => {
                        if (isShieldMode) {
                            // シールドチャートモード：シンボルを確定して次へ
                            finalizeSymbol();
                        } else {
                            // ワンオラクルモード：結果画面に遷移
                            const pattern = completedRounds.join('');
                            window.location.href = `one-oracle.html?pattern=${pattern}&method=stones`;
                        }
                    }, 800);
                } else {
                    setTimeout(() => {
                        currentPath = [];
                        currentRoundResult = null;
                        redraw();
                    }, 1500);
                }
            });
        }

        function animatePairing(enclosedStones, callback) {
            const sortedStones = sortSpiralInward([...enclosedStones]);
            
            let pairIndex = 0;
            const isEven = sortedStones.length % 2 === 0;
            const stonesToPair = isEven ? sortedStones.length - 2 : sortedStones.length - 1;
            const totalPairs = Math.floor(stonesToPair / 2);
            
            function drawNextPair() {
                if (pairIndex >= totalPairs) {
                    // ペアリング完了後、残った石を金色で強調
                    const remainingStones = sortedStones.slice(totalPairs * 2);
                    remainingStones.forEach(stone => {
                        ctx.fillStyle = '#f39c12';
                        ctx.beginPath();
                        ctx.arc(stone.x, stone.y, STONE_RADIUS * 1.8, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    if (callback) setTimeout(callback, 300);
                    return;
                }
                
                const stone1 = sortedStones[pairIndex * 2];
                const stone2 = sortedStones[pairIndex * 2 + 1];
                
                ctx.strokeStyle = '#8b7355';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(stone1.x, stone1.y);
                ctx.lineTo(stone2.x, stone2.y);
                ctx.stroke();
                
                pairIndex++;
                setTimeout(drawNextPair, 100);
            }
            
            drawNextPair();
        }

        function sortSpiralInward(stones) {
            const result = [];
            let remaining = [...stones];
            let direction = 0;
            
            while (remaining.length > 0) {
                switch (direction % 4) {
                    case 0:
                        remaining.sort((a, b) => a.x - b.x);
                        break;
                    case 1:
                        remaining.sort((a, b) => a.y - b.y);
                        break;
                    case 2:
                        remaining.sort((a, b) => b.x - a.x);
                        break;
                    case 3:
                        remaining.sort((a, b) => b.y - a.y);
                        break;
                }
                
                const count = Math.min(2, remaining.length);
                for (let i = 0; i < count; i++) {
                    result.push(remaining.shift());
                }
                
                direction++;
            }
            
            return result;
        }

        function updateResults() {
            const elements = ['fire', 'air', 'water', 'earth'];
            for (let i = 0; i < elements.length; i++) {
                const resultElement = document.getElementById(`result-${elements[i]}`);
                if (i < completedRounds.length) {
                    resultElement.textContent = completedRounds[i];
                    resultElement.classList.remove('empty');
                } else {
                    resultElement.textContent = '-';
                    resultElement.classList.add('empty');
                }
            }
        }

        function finalizeSymbol() {
            const pattern = completedRounds.join('');
            completedSymbols.push(pattern);
            
            // シンボルスロットに画像を表示（右から順に：3, 2, 1, 0）
            const slotIndex = 3 - currentSymbolIndex;
            const slot = document.getElementById(`symbol-slot-${slotIndex}`);
            const img = document.createElement('img');
            img.src = `${pattern}.png`;
            img.alt = pattern;
            slot.appendChild(img);
            
            // 枠線と背景色を削除
            slot.style.border = 'none';
            slot.style.background = 'transparent';
            
            // 次のシンボルへ
            currentSymbolIndex++;
            
            if (currentSymbolIndex >= 4) {
                // 4つすべて完了：結果画面に遷移
                setTimeout(() => {
                    const params = new URLSearchParams({
                        m1: completedSymbols[0],
                        m2: completedSymbols[1],
                        m3: completedSymbols[2],
                        m4: completedSymbols[3],
                        method: 'stones'
                    });
                    window.location.href = `shield-chart.html?${params.toString()}`;
                }, 800);
                return;
            }
            
            // 次のシンボル生成のためにリセット
            setTimeout(() => {
                completedRounds = [];
                currentPath = [];
                currentRoundResult = null;
                updateResults();
                initStones();
                redraw();
            }, 1000);
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', endDrawing);
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', endDrawing);

        window.addEventListener('resize', () => {
            resizeCanvas();
            redraw();
        });

        document.addEventListener('DOMContentLoaded', function() {
            if ('scrollRestoration' in history) {
                history.scrollRestoration = 'manual';
            }
            window.scrollTo(0, 0);
            
            // シールドチャートモードの場合はシンボルスロットを表示し、説明文を変更
            if (isShieldMode) {
                document.getElementById('symbol-slots').style.display = 'flex';
                const instructionText = document.getElementById('instruction-text');
                instructionText.textContent = 'どんなことを占いたいのかを強く心に思いながら、画面上のさざれ石を指でなぞって囲んでください。閉じた線を4回描くことで、ジオマンシーのシンボルが決まります。囲んだ石の数が偶数か奇数かで判定されます。シールドチャートでは、この操作を4回繰り返して4つのシンボルを生成します。';
            }
            
            resizeCanvas();
            initStones();
            redraw();
        });
    </script>
</body>
</html>
