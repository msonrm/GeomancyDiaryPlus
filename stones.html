<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ワンオラクル（さざれ石）- ジオマンシー占い</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Hiragino Sans', 'Noto Sans JP', sans-serif;
            background: linear-gradient(135deg, #e8dcc6 0%, #d4c4a8 100%);
            min-height: 100vh;
            color: #5d4e37;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: none;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .back-button {
            background: none;
            border: none;
            color: #5d4e37;
            padding: 16px 20px;
            font-size: 16px;
            cursor: pointer;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            text-decoration: none;
            display: block;
            text-align: left;
        }

        .back-button:hover {
            color: #8b7355;
        }

        .canvas-container {
            width: 100%;
            aspect-ratio: 1;
            max-width: 600px;
            margin: 0 auto;
            position: relative;
            background: #3d3d5c;
            border-radius: 12px;
            touch-action: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        #stones-canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            border-radius: 12px;
        }

        .dice-results {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin: 20px 0;
            padding: 0 20px;
        }

        .dice-result-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .dice-result-box {
            background: rgba(255,255,255,0.9);
            border-radius: 8px;
            padding: 12px;
            width: 60px;
            height: 60px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 2px solid transparent;
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .dice-result-box.fire {
            border-color: #ffaaaa;
            background: #ffdddd;
        }

        .dice-result-box.air {
            border-color: #ffffaa;
            background: #ffffdd;
        }

        .dice-result-box.water {
            border-color: #aaccff;
            background: #ddeeff;
        }

        .dice-result-box.earth {
            border-color: #aaffaa;
            background: #ddffdd;
        }

        .element-label {
            font-size: 11px;
            color: rgba(93,78,55,0.8);
            font-weight: 600;
        }

        .dice-value {
            font-size: 20px;
            font-weight: bold;
            color: #5d4e37;
        }

        .dice-value.empty {
            color: rgba(93,78,55,0.3);
            font-size: 16px;
        }

        .symbol-slots {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin: 20px 0;
            padding: 0 20px;
        }

        .symbol-slot {
            background: rgba(255,255,255,0.5);
            border: 2px solid rgba(139,115,85,0.3);
            border-radius: 8px;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .symbol-slot img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        @media (max-width: 480px) {
            .container {
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <button class="back-button" onclick="goBack()">← 戻る</button>
        
        <div style="flex: 1; display: flex; flex-direction: column;">
            <div class="canvas-container">
                <canvas id="stones-canvas"></canvas>
            </div>
            
            <div style="padding: 16px 20px 20px 20px; text-align: center;">
                <p style="color: rgba(93,78,55,0.7); font-size: 14px; margin-bottom: 16px; line-height: 1.4;" id="instruction-text">
                    どんなことを占いたいのかを強く心に思いながら、画面上のさざれ石を指でなぞって囲んでください。閉じた線を4回描くことで、ジオマンシーのシンボルが決まります。囲んだ石の数が偶数か奇数かで判定されます。
                </p>
                
                <div class="dice-results">
                    <div class="dice-result-container">
                        <div class="dice-result-box fire">
                            <span class="dice-value empty" id="result-fire">-</span>
                        </div>
                        <span class="element-label">火</span>
                    </div>
                    <div class="dice-result-container">
                        <div class="dice-result-box air">
                            <span class="dice-value empty" id="result-air">-</span>
                        </div>
                        <span class="element-label">風</span>
                    </div>
                    <div class="dice-result-container">
                        <div class="dice-result-box water">
                            <span class="dice-value empty" id="result-water">-</span>
                        </div>
                        <span class="element-label">水</span>
                    </div>
                    <div class="dice-result-container">
                        <div class="dice-result-box earth">
                            <span class="dice-value empty" id="result-earth">-</span>
                        </div>
                        <span class="element-label">地</span>
                    </div>
                </div>
                
                <div class="symbol-slots" id="symbol-slots" style="display: none;">
                    <div class="symbol-slot" id="symbol-slot-0"></div>
                    <div class="symbol-slot" id="symbol-slot-1"></div>
                    <div class="symbol-slot" id="symbol-slot-2"></div>
                    <div class="symbol-slot" id="symbol-slot-3"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const mode = urlParams.get('mode') || 'oneoracle';
        const isShieldMode = mode === 'shield';
        
        const canvas = document.getElementById('stones-canvas');
        const ctx = canvas.getContext('2d');
        
        let stones = [];
        let currentPath = [];
        let isDrawing = false;
        let completedRounds = [];
        let currentRoundResult = null;
        
        let completedSymbols = [];
        let currentSymbolIndex = 0;
        
        const STONE_BASE_RADIUS = 8;
        const STONE_COUNT = 50;
        const CLOSE_THRESHOLD = 30;
        const MIN_PATH_LENGTH = 20;

        // 石の色パレット（水晶のような色合い）
        const stoneColors = [
            '#e8d5f2', '#d4c5f9', '#c8b6ff', '#dfd3ff',
            '#f0e6ff', '#e6d9ff', '#cfc2e8', '#d8cce8'
        ];

        function goBack() {
            window.history.back();
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        // 不規則な多角形の頂点を生成
        function generateIrregularPolygon(centerX, centerY, baseRadius) {
            const sides = 6 + Math.floor(Math.random() * 5); // 6-10角形
            const points = [];
            const angleStep = (Math.PI * 2) / sides;
            
            for (let i = 0; i < sides; i++) {
                const angle = angleStep * i + (Math.random() - 0.5) * 0.3;
                const radiusVariation = baseRadius * (0.8 + Math.random() * 0.4);
                const x = centerX + Math.cos(angle) * radiusVariation;
                const y = centerY + Math.sin(angle) * radiusVariation;
                points.push({ x, y });
            }
            
            return points;
        }

        function initStones() {
            stones = [];
            const MIN_DISTANCE = STONE_BASE_RADIUS * 5;
            const EDGE_MARGIN = 20;
            const MAX_ATTEMPTS = 50;
            
            for (let i = 0; i < STONE_COUNT; i++) {
                let attempts = 0;
                let newStone = null;
                let validPosition = false;
                
                while (!validPosition && attempts < MAX_ATTEMPTS) {
                    const x = EDGE_MARGIN + Math.random() * (canvas.width - EDGE_MARGIN * 2);
                    const y = EDGE_MARGIN + Math.random() * (canvas.height - EDGE_MARGIN * 2);
                    const radius = STONE_BASE_RADIUS * (0.8 + Math.random() * 0.4);
                    const color = stoneColors[Math.floor(Math.random() * stoneColors.length)];
                    
                    // 石の形状を最初に生成（相対座標）
                    const basePolygon = generateIrregularPolygon(0, 0, radius);
                    
                    // キャンバスの中心座標
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // 最終位置から中心とは逆方向のベクトルを計算（外側から中心に向かう）
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // 50〜150pxのランダムな距離
                    const moveDistance = 50 + Math.random() * 100;
                    const startX = x + (dx / distance) * moveDistance;
                    const startY = y + (dy / distance) * moveDistance;
                    
                    newStone = { 
                        x, 
                        y, 
                        radius, 
                        color, 
                        basePolygon: basePolygon, // 基準形状（相対座標）
                        polygon: null, // 描画用（絶対座標）
                        // アニメーション用の初期位置と目標位置
                        startX: startX,
                        startY: startY,
                        targetX: x,
                        targetY: y,
                        animProgress: 0,
                        animDelay: Math.random() * 200 // 0〜200msのランダムな遅延
                    };
                    
                    validPosition = true;
                    for (let j = 0; j < stones.length; j++) {
                        const distance = Math.hypot(newStone.targetX - stones[j].targetX, newStone.targetY - stones[j].targetY);
                        if (distance < MIN_DISTANCE) {
                            validPosition = false;
                            break;
                        }
                    }
                    
                    attempts++;
                }
                
                if (newStone) {
                    stones.push(newStone);
                }
            }
            
            // 石を混ぜるアニメーション
            animateStonesMixing();
        }

        function animateStonesMixing() {
            const duration = 800; // ミリ秒
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                
                stones.forEach(stone => {
                    // 各石の遅延を考慮
                    const stoneElapsed = Math.max(0, elapsed - stone.animDelay);
                    const progress = Math.min(stoneElapsed / duration, 1);
                    
                    // イージング関数（ease-out）
                    const easeProgress = 1 - Math.pow(1 - progress, 3);
                    
                    stone.animProgress = easeProgress;
                    stone.x = stone.startX + (stone.targetX - stone.startX) * easeProgress;
                    stone.y = stone.startY + (stone.targetY - stone.startY) * easeProgress;
                    
                    // 基準形状から現在位置の絶対座標を計算
                    stone.polygon = stone.basePolygon.map(point => ({
                        x: point.x + stone.x,
                        y: point.y + stone.y
                    }));
                });
                
                redraw();
                
                // 全ての石のアニメーションが完了するまで継続
                const allComplete = stones.every(stone => 
                    (elapsed - stone.animDelay) >= duration
                );
                
                if (!allComplete) {
                    requestAnimationFrame(animate);
                } else {
                    // アニメーション完了後、位置を確定
                    stones.forEach(stone => {
                        stone.x = stone.targetX;
                        stone.y = stone.targetY;
                        stone.polygon = stone.basePolygon.map(point => ({
                            x: point.x + stone.x,
                            y: point.y + stone.y
                        }));
                    });
                    redraw();
                }
            }
            
            animate();
        }

        function drawStone(stone, glow = false) {
            ctx.save();
            
            if (glow) {
                // グロー効果（輝き）- 残った石用
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 20;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            } else {
                // 通常の影 - 実在感を出す
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
            }
            
            // 多角形を描画
            ctx.beginPath();
            ctx.moveTo(stone.polygon[0].x, stone.polygon[0].y);
            for (let i = 1; i < stone.polygon.length; i++) {
                ctx.lineTo(stone.polygon[i].x, stone.polygon[i].y);
            }
            ctx.closePath();
            
            // グラデーションで立体感と輝きを出す
            const gradient = ctx.createRadialGradient(
                stone.x - stone.radius * 0.3, 
                stone.y - stone.radius * 0.3, 
                0,
                stone.x, 
                stone.y, 
                stone.radius * 1.5
            );
            
            const baseColor = stone.color;
            const lighterColor = glow ? '#ffffff' : lightenColor(baseColor, 40);
            const darkerColor = darkenColor(baseColor, 10);
            
            gradient.addColorStop(0, lighterColor);
            gradient.addColorStop(0.5, baseColor);
            gradient.addColorStop(1, darkerColor);
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // 輪郭線
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.strokeStyle = lightenColor(baseColor, 20);
            ctx.lineWidth = 0.5;
            ctx.stroke();
            
            // 追加のグロー効果（輝く石用）
            if (glow) {
                ctx.shadowColor = '#fff';
                ctx.shadowBlur = 30;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function lightenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, ((num >> 16) & 0xff) + amt);
            const G = Math.min(255, ((num >> 8) & 0xff) + amt);
            const B = Math.min(255, (num & 0xff) + amt);
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        function darkenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, ((num >> 16) & 0xff) - amt);
            const G = Math.max(0, ((num >> 8) & 0xff) - amt);
            const B = Math.max(0, (num & 0xff) - amt);
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            stones.forEach(stone => {
                drawStone(stone);
            });
            
            if (currentPath.length > 0) {
                ctx.strokeStyle = '#fff8e1';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.shadowColor = '#fff8e1';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(currentPath[0].x, currentPath[0].y);
                for (let i = 1; i < currentPath.length; i++) {
                    ctx.lineTo(currentPath[i].x, currentPath[i].y);
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                if (currentPath.length > MIN_PATH_LENGTH) {
                    const startPoint = currentPath[0];
                    const endPoint = currentPath[currentPath.length - 1];
                    const distance = Math.hypot(endPoint.x - startPoint.x, endPoint.y - startPoint.y);
                    
                    if (distance < CLOSE_THRESHOLD) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
                        ctx.shadowBlur = 0;
                        ctx.beginPath();
                        ctx.moveTo(currentPath[0].x, currentPath[0].y);
                        for (let i = 1; i < currentPath.length; i++) {
                            ctx.lineTo(currentPath[i].x, currentPath[i].y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.strokeStyle = 'rgba(255, 248, 225, 0.7)';
                        ctx.shadowColor = '#fff8e1';
                        ctx.shadowBlur = 8;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(endPoint.x, endPoint.y);
                        ctx.lineTo(startPoint.x, startPoint.y);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.shadowBlur = 0;
                    }
                }
            }
            
            if (currentRoundResult && currentRoundResult.path) {
                const path = currentRoundResult.path;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x, path[i].y);
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = '#fff8e1';
                ctx.shadowColor = '#fff8e1';
                ctx.shadowBlur = 10;
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
        }

        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }

        function startDrawing(e) {
            e.preventDefault();
            isDrawing = true;
            const pos = getPointerPos(e);
            currentPath = [pos];
            currentRoundResult = null;
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            
            const pos = getPointerPos(e);
            currentPath.push(pos);
            
            if (currentPath.length > MIN_PATH_LENGTH) {
                const intersection = checkLastSegmentIntersection(currentPath);
                
                if (intersection.intersects) {
                    const newPath = [];
                    newPath.push(intersection.point);
                    
                    for (let i = intersection.index1 + 1; i <= intersection.index2; i++) {
                        newPath.push(currentPath[i]);
                    }
                    
                    newPath.push(intersection.point);
                    
                    currentPath = newPath;
                    isDrawing = false;
                    countEnclosedStones();
                    return;
                }
            }
            
            redraw();
        }

        function checkLastSegmentIntersection(path) {
            const lastIndex = path.length - 1;
            if (lastIndex < 3) return { intersects: false };
            
            const lastSegmentStart = path[lastIndex - 1];
            const lastSegmentEnd = path[lastIndex];
            
            for (let i = 0; i < lastIndex - 2; i++) {
                if (lineSegmentsIntersect(
                    lastSegmentStart, lastSegmentEnd,
                    path[i], path[i + 1]
                )) {
                    const intersectionPoint = getIntersectionPoint(
                        lastSegmentStart, lastSegmentEnd,
                        path[i], path[i + 1]
                    );
                    return {
                        intersects: true,
                        index1: i,
                        index2: lastIndex - 1,
                        point: intersectionPoint
                    };
                }
            }
            
            return { intersects: false };
        }

        function lineSegmentsIntersect(p1, p2, p3, p4) {
            const ccw = (A, B, C) => {
                return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);
            };
            return ccw(p1, p3, p4) !== ccw(p2, p3, p4) && ccw(p1, p2, p3) !== ccw(p1, p2, p4);
        }

        function getIntersectionPoint(p1, p2, p3, p4) {
            const x1 = p1.x, y1 = p1.y;
            const x2 = p2.x, y2 = p2.y;
            const x3 = p3.x, y3 = p3.y;
            const x4 = p4.x, y4 = p4.y;
            
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 0.0001) return null;
            
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            
            return {
                x: x1 + t * (x2 - x1),
                y: y1 + t * (y2 - y1)
            };
        }

        function endDrawing(e) {
            if (!isDrawing) return;
            e.preventDefault();
            isDrawing = false;
            
            if (currentPath.length > MIN_PATH_LENGTH) {
                const startPoint = currentPath[0];
                const endPoint = currentPath[currentPath.length - 1];
                const distance = Math.hypot(endPoint.x - startPoint.x, endPoint.y - startPoint.y);
                
                if (distance < CLOSE_THRESHOLD) {
                    currentPath.push(startPoint);
                    countEnclosedStones();
                } else {
                    currentPath = [];
                    redraw();
                }
            } else {
                currentPath = [];
                redraw();
            }
        }

        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                
                const intersect = ((yi > point.y) !== (yj > point.y))
                    && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function countEnclosedStones() {
            const enclosedStones = stones.filter(stone => isPointInPolygon(stone, currentPath));
            const count = enclosedStones.length;
            
            if (count === 0) {
                currentPath = [];
                currentRoundResult = null;
                redraw();
                return;
            }
            
            const parity = count % 2 === 0 ? 2 : 1;
            
            currentRoundResult = {
                path: [...currentPath],
                count: count,
                parity: parity,
                enclosedStones: enclosedStones
            };
            
            completedRounds.push(parity);
            
            redraw();
            
            animatePairing(enclosedStones, () => {
                updateResults();
                
                if (completedRounds.length === 4) {
                    setTimeout(() => {
                        if (isShieldMode) {
                            finalizeSymbol();
                        } else {
                            const pattern = completedRounds.join('');
                            window.location.href = `one-oracle.html?pattern=${pattern}&method=stones`;
                        }
                    }, 800);
                } else {
                    setTimeout(() => {
                        currentPath = [];
                        currentRoundResult = null;
                        redraw();
                    }, 1500);
                }
            });
        }

        function animatePairing(enclosedStones, callback) {
            const sortedStones = sortSpiralInward([...enclosedStones]);
            
            let pairIndex = 0;
            const isEven = sortedStones.length % 2 === 0;
            const stonesToPair = isEven ? sortedStones.length - 2 : sortedStones.length - 1;
            const totalPairs = Math.floor(stonesToPair / 2);
            
            function drawNextPair() {
                if (pairIndex >= totalPairs) {
                    const remainingStones = sortedStones.slice(totalPairs * 2);
                    
                    // 残った石を輝かせる
                    remainingStones.forEach(stone => {
                        drawStone(stone, true);
                    });
                    
                    if (callback) setTimeout(callback, 300);
                    return;
                }
                
                const stone1 = sortedStones[pairIndex * 2];
                const stone2 = sortedStones[pairIndex * 2 + 1];
                
                ctx.strokeStyle = '#9d8db8';
                ctx.shadowColor = '#9d8db8';
                ctx.shadowBlur = 3;
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(stone1.x, stone1.y);
                ctx.lineTo(stone2.x, stone2.y);
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                pairIndex++;
                setTimeout(drawNextPair, 100);
            }
            
            drawNextPair();
        }

        function sortSpiralInward(stones) {
            const result = [];
            let remaining = [...stones];
            let direction = 0;
            
            while (remaining.length > 0) {
                switch (direction % 4) {
                    case 0:
                        remaining.sort((a, b) => a.x - b.x);
                        break;
                    case 1:
                        remaining.sort((a, b) => a.y - b.y);
                        break;
                    case 2:
                        remaining.sort((a, b) => b.x - a.x);
                        break;
                    case 3:
                        remaining.sort((a, b) => b.y - a.y);
                        break;
                }
                
                const count = Math.min(2, remaining.length);
                for (let i = 0; i < count; i++) {
                    result.push(remaining.shift());
                }
                
                direction++;
            }
            
            return result;
        }

        function updateResults() {
            const elements = ['fire', 'air', 'water', 'earth'];
            for (let i = 0; i < elements.length; i++) {
                const resultElement = document.getElementById(`result-${elements[i]}`);
                if (i < completedRounds.length) {
                    resultElement.textContent = completedRounds[i];
                    resultElement.classList.remove('empty');
                } else {
                    resultElement.textContent = '-';
                    resultElement.classList.add('empty');
                }
            }
        }

        function finalizeSymbol() {
            const pattern = completedRounds.join('');
            completedSymbols.push(pattern);
            
            const slotIndex = 3 - currentSymbolIndex;
            const slot = document.getElementById(`symbol-slot-${slotIndex}`);
            const img = document.createElement('img');
            img.src = `${pattern}.png`;
            img.alt = pattern;
            slot.appendChild(img);
            
            slot.style.border = 'none';
            slot.style.background = 'transparent';
            
            currentSymbolIndex++;
            
            if (currentSymbolIndex >= 4) {
                setTimeout(() => {
                    const params = new URLSearchParams({
                        m1: completedSymbols[0],
                        m2: completedSymbols[1],
                        m3: completedSymbols[2],
                        m4: completedSymbols[3],
                        method: 'stones'
                    });
                    window.location.href = `shield-chart.html?${params.toString()}`;
                }, 800);
                return;
            }
            
            setTimeout(() => {
                completedRounds = [];
                currentPath = [];
                currentRoundResult = null;
                updateResults();
                initStones();
                redraw();
            }, 1000);
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', endDrawing);
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', endDrawing);

        window.addEventListener('resize', () => {
            resizeCanvas();
            redraw();
        });

        document.addEventListener('DOMContentLoaded', function() {
            if ('scrollRestoration' in history) {
                history.scrollRestoration = 'manual';
            }
            window.scrollTo(0, 0);
            
            if (isShieldMode) {
                document.getElementById('symbol-slots').style.display = 'flex';
                const instructionText = document.getElementById('instruction-text');
                instructionText.textContent = 'どんなことを占いたいのかを強く心に思いながら、画面上のさざれ石を指でなぞって囲んでください。閉じた線を4回描くことで、ジオマンシーのシンボルが決まります。囲んだ石の数が偶数か奇数かで判定されます。シールドチャートでは、この操作を4回繰り返して4つのシンボルを生成します。';
            }
            
            resizeCanvas();
            initStones();
            redraw();
        });
    </script>
</body>
</html>
