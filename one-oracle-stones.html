<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ワンオラクル（さざれ石）- ジオマンシー占い</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Hiragino Sans', 'Noto Sans JP', sans-serif;
            background: linear-gradient(135deg, #e8dcc6 0%, #d4c4a8 100%);
            min-height: 100vh;
            color: #5d4e37;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: none;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .back-button {
            background: none;
            border: none;
            color: #5d4e37;
            padding: 16px 20px;
            font-size: 16px;
            cursor: pointer;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            text-decoration: none;
            display: block;
            text-align: left;
        }

        .back-button:hover {
            color: #8b7355;
        }

        .instructions {
            background: rgba(255,255,255,0.7);
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 20px;
            font-size: 14px;
            line-height: 1.6;
            color: rgba(93,78,55,0.9);
        }

        .progress-indicator {
            text-align: center;
            margin-bottom: 16px;
            font-size: 16px;
            font-weight: 600;
            color: #5d4e37;
        }

        .progress-dots {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 8px;
        }

        .progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(139,115,85,0.3);
            transition: all 0.3s ease;
        }

        .progress-dot.completed {
            background: #8b7355;
        }

        .canvas-container {
            position: relative;
            background: rgba(255,255,255,0.6);
            border-radius: 12px;
            overflow: hidden;
            touch-action: none;
            flex: 1;
            min-height: 400px;
        }

        #stones-canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .result-display {
            text-align: center;
            margin-top: 16px;
            padding: 12px;
            background: rgba(255,255,255,0.7);
            border-radius: 12px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .result-text {
            font-size: 18px;
            font-weight: 600;
            color: #5d4e37;
        }

        .result-number {
            font-size: 24px;
            font-weight: bold;
            color: #8b7355;
            margin: 0 8px;
        }

        .symbol-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .symbol-dialog.show {
            opacity: 1;
            visibility: visible;
        }

        .symbol-content {
            background: #f5f0e8;
            border: 2px solid #8b7355;
            border-radius: 12px;
            width: calc(100% - 40px);
            max-width: 400px;
            position: relative;
            padding: 24px;
            opacity: 0;
            transform: scale(0.9);
            transition: opacity 0.8s ease, transform 0.8s ease;
        }

        .symbol-dialog.show .symbol-content {
            opacity: 1;
            transform: scale(1);
        }

        .symbol-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .symbol-header h3 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: #5d4e37;
        }

        .close-button {
            background: none;
            border: none;
            font-size: 24px;
            color: #8b7355;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .close-button:hover {
            background: rgba(139,115,85,0.1);
            color: #5d4e37;
        }

        .symbol-image-area {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255,255,255,0.5);
            border-radius: 8px;
            border: 1px solid rgba(139,115,85,0.2);
        }

        .symbol-image {
            max-width: 100%;
            height: auto;
            max-height: 200px;
        }

        .symbol-name {
            font-size: 18px;
            font-weight: 600;
            color: #5d4e37;
            text-align: center;
            margin-bottom: 16px;
        }

        .symbol-attributes {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .symbol-attribute {
            background: rgba(139,115,85,0.1);
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 13px;
            color: #5d4e37;
            font-weight: 500;
        }

        .symbol-meaning {
            font-size: 15px;
            color: #5d4e37;
            line-height: 1.6;
            text-align: left;
        }

        @media (max-width: 480px) {
            .container {
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <button class="back-button" onclick="goBack()">← 戻る</button>
        
        <div class="instructions">
            画面上のさざれ石を指でなぞって囲んでください。閉じた線を4回描くことで、シンボルが決まります。囲んだ石の数が偶数か奇数かで判定されます。
        </div>

        <div class="progress-indicator">
            <div>囲んだ回数: <span id="round-count">0</span> / 4</div>
            <div class="progress-dots">
                <div class="progress-dot" id="progress-0"></div>
                <div class="progress-dot" id="progress-1"></div>
                <div class="progress-dot" id="progress-2"></div>
                <div class="progress-dot" id="progress-3"></div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="stones-canvas"></canvas>
        </div>

        <div class="result-display">
            <span class="result-text" id="result-text">石を囲んで線を閉じてください</span>
        </div>
    </div>

    <div class="symbol-dialog" id="symbolDialog">
        <div class="symbol-content">
            <div class="symbol-header">
                <h3>ワンオラクル結果</h3>
                <button class="close-button" onclick="closeSymbolDialog()">×</button>
            </div>
            
            <div class="symbol-image-area">
                <img class="symbol-image" id="symbol-image" src="" alt="シンボル">
            </div>
            
            <div class="symbol-name" id="symbol-name">
                Fortuna Minor（小吉）
            </div>
            
            <div class="symbol-attributes">
                <div class="symbol-attribute" id="symbol-yesno">Yes/No: イエス</div>
                <div class="symbol-attribute" id="symbol-fortune">吉凶: 小吉</div>
            </div>
            
            <div class="symbol-meaning" id="symbol-meaning">
                小さく一時的な幸運、ささやかな幸せ。周りからの援助。
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('stones-canvas');
        const ctx = canvas.getContext('2d');
        
        let stones = [];
        let currentPath = [];
        let isDrawing = false;
        let completedRounds = [];
        let currentRoundResult = null;
        
        const STONE_RADIUS = 3;
        const STONE_COUNT = 100;
        const CLOSE_THRESHOLD = 30;
        const MIN_PATH_LENGTH = 20;

        const geomancySymbols = {
            '2222': { name: 'Populus（人々）', meaning: '物事や人が多数ある状態。受け身。安定。', yesno: 'イエス', fortune: '吉' },
            '1111': { name: 'Via（道）', meaning: '変化、動くこと、過程。決断。積極性、能動性。', yesno: 'ノー', fortune: '吉でも凶でもない。旅や移動について吉' },
            '2112': { name: 'Conjunctio（つながり）', meaning: '違う者同士結びつく、目的を持って集まる、縁が生まれる。失せ物が見つかる。', yesno: 'イエス', fortune: '吉と凶の両方' },
            '1221': { name: 'Carcer（拘束）', meaning: '孤独、身動きが取れない、ひきこもり。困滞、現状維持。', yesno: 'ノー', fortune: '凶。セキュリティに関しては吉' },
            '2211': { name: 'Fortuna Major（大吉）', meaning: '大きな幸運。自分の思い通りにことが運ぶ。', yesno: 'イエス', fortune: '大吉' },
            '1122': { name: 'Fortuna Minor（小吉）', meaning: '小さく一時的な幸運、ささやかな幸せ。周りからの援助。', yesno: 'イエス', fortune: '小吉' },
            '2121': { name: 'Acquisitio（獲得）', meaning: '収穫、利益。願いが叶う。何かを受け取る、受け入れる。', yesno: 'イエス', fortune: '吉' },
            '1212': { name: 'Amissio（喪失）', meaning: '損失、愛情や金銭などを失う。病気やトラブル、悪癖がなくなる。', yesno: 'ノー', fortune: '凶' },
            '1222': { name: 'Laetitia（喜び）', meaning: '喜ばしいこと、笑い、成功。音楽や踊り。髭のある男性。', yesno: 'イエス', fortune: '吉' },
            '2221': { name: 'Tristitia（悲しみ）', meaning: '不幸、受難、宿命。', yesno: 'ノー', fortune: '凶。占いや魔術に関しては吉' },
            '1211': { name: 'Puella（少女）', meaning: '女性らしさ、美しさ。ときめき、嬉しさ。目先の楽しみ。', yesno: 'イエス', fortune: '吉' },
            '1121': { name: 'Puer（少年）', meaning: '男性らしさ、力強さ、未熟さ。未来を切り開く。', yesno: 'ノー', fortune: '凶。争い事には吉' },
            '2212': { name: 'Albus（白）', meaning: '公正、高潔さ、正義。片思いやプラトニック・ラブ。', yesno: 'イエス', fortune: '吉' },
            '2122': { name: 'Rubeus（赤）', meaning: '争い事、闘争心。悪いことには吉、良いことには凶。', yesno: 'ノー', fortune: '凶' },
            '2111': { name: 'Caput Draconis（竜の頭）', meaning: '始まり、新しい扉が開く、前例のない課題に取り組む。やりすぎの傾向。', yesno: 'イエス', fortune: '吉凶入り混じる。何かを始めるには吉' },
            '1112': { name: 'Cauda Draconis（竜の尾）', meaning: '終わり、物事の完成、途絶。吉は凶となり、凶は吉となる。', yesno: 'ノー', fortune: '吉でも凶でもない。何かを終わらせるには吉' }
        };

        function goBack() {
            window.history.back();
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            redraw();
        }

        function initStones() {
            stones = [];
            const margin = 30;
            for (let i = 0; i < STONE_COUNT; i++) {
                stones.push({
                    x: margin + Math.random() * (canvas.width - margin * 2),
                    y: margin + Math.random() * (canvas.height - margin * 2)
                });
            }
        }

        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // さざれ石を描画
            stones.forEach(stone => {
                ctx.fillStyle = '#8b7355';
                ctx.beginPath();
                ctx.arc(stone.x, stone.y, STONE_RADIUS, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // 現在描いている線を描画
            if (currentPath.length > 0) {
                ctx.strokeStyle = '#5d4e37';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(currentPath[0].x, currentPath[0].y);
                for (let i = 1; i < currentPath.length; i++) {
                    ctx.lineTo(currentPath[i].x, currentPath[i].y);
                }
                ctx.stroke();
                
                // 始点に近い場合、閉じる予告線を描画
                if (currentPath.length > MIN_PATH_LENGTH) {
                    const startPoint = currentPath[0];
                    const endPoint = currentPath[currentPath.length - 1];
                    const distance = Math.hypot(endPoint.x - startPoint.x, endPoint.y - startPoint.y);
                    
                    if (distance < CLOSE_THRESHOLD) {
                        ctx.strokeStyle = 'rgba(139,115,85,0.5)';
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(endPoint.x, endPoint.y);
                        ctx.lineTo(startPoint.x, startPoint.y);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
            }
            
            // 確定した領域をハイライト
            if (currentRoundResult && currentRoundResult.path) {
                const path = currentRoundResult.path;
                
                // 塗りつぶし
                ctx.fillStyle = 'rgba(139,115,85,0.15)';
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x, path[i].y);
                }
                ctx.closePath();
                ctx.fill();
                
                // 線の描画
                ctx.strokeStyle = '#8b7355';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // 囲まれた石を強調表示
                currentRoundResult.enclosedStones.forEach(stone => {
                    ctx.fillStyle = '#d4a574';
                    ctx.beginPath();
                    ctx.arc(stone.x, stone.y, STONE_RADIUS + 2, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }

        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            return {
                x: touch.clientX - rect.left,
                y: touch.clientY - rect.top
            };
        }

        function startDrawing(e) {
            e.preventDefault();
            isDrawing = true;
            const pos = getPointerPos(e);
            currentPath = [pos];
            currentRoundResult = null;
            updateResultDisplay('線を描いています...');
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            
            const pos = getPointerPos(e);
            currentPath.push(pos);
            
            // 交差をチェック（リアルタイム）
            if (currentPath.length > MIN_PATH_LENGTH) {
                const intersection = checkLastSegmentIntersection(currentPath);
                
                if (intersection.intersects) {
                    // 交差が発生したら即座に閉曲線を確定
                    const newPath = [];
                    
                    // 交差点を追加
                    newPath.push(intersection.point);
                    
                    // 交差点から交差点まで（ループ部分）
                    for (let i = intersection.index1 + 1; i <= intersection.index2; i++) {
                        newPath.push(currentPath[i]);
                    }
                    
                    // 交差点に戻る
                    newPath.push(intersection.point);
                    
                    currentPath = newPath;
                    isDrawing = false; // 描画終了
                    countEnclosedStones();
                    return;
                }
            }
            
            redraw();
            
            // 始点に近づいたかチェック
            if (currentPath.length > MIN_PATH_LENGTH) {
                const startPoint = currentPath[0];
                const distance = Math.hypot(pos.x - startPoint.x, pos.y - startPoint.y);
                
                if (distance < CLOSE_THRESHOLD) {
                    updateResultDisplay('指を離すと確定します');
                } else {
                    updateResultDisplay('線を描いています');
                }
            }
        }

        function checkLastSegmentIntersection(path) {
            // 最後に追加されたセグメントが既存のセグメントと交差するかチェック
            const lastIndex = path.length - 1;
            if (lastIndex < 3) return { intersects: false };
            
            const lastSegmentStart = path[lastIndex - 1];
            const lastSegmentEnd = path[lastIndex];
            
            // 最後のセグメント以外の全セグメントとチェック
            for (let i = 0; i < lastIndex - 2; i++) {
                if (lineSegmentsIntersect(
                    lastSegmentStart, lastSegmentEnd,
                    path[i], path[i + 1]
                )) {
                    const intersectionPoint = getIntersectionPoint(
                        lastSegmentStart, lastSegmentEnd,
                        path[i], path[i + 1]
                    );
                    return {
                        intersects: true,
                        index1: i,
                        index2: lastIndex - 1,
                        point: intersectionPoint
                    };
                }
            }
            
            return { intersects: false };
        }

        function lineSegmentsIntersect(p1, p2, p3, p4) {
            const ccw = (A, B, C) => {
                return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);
            };
            return ccw(p1, p3, p4) !== ccw(p2, p3, p4) && ccw(p1, p2, p3) !== ccw(p1, p2, p4);
        }

        function getIntersectionPoint(p1, p2, p3, p4) {
            const x1 = p1.x, y1 = p1.y;
            const x2 = p2.x, y2 = p2.y;
            const x3 = p3.x, y3 = p3.y;
            const x4 = p4.x, y4 = p4.y;
            
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 0.0001) return null;
            
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            
            return {
                x: x1 + t * (x2 - x1),
                y: y1 + t * (y2 - y1)
            };
        }

        function getAllIntersections(path) {
            // すべての交差点を見つける
            const intersections = [];
            
            for (let i = 0; i < path.length - 1; i++) {
                for (let j = i + 2; j < path.length - 1; j++) {
                    // 隣接するセグメントは除外
                    if (Math.abs(i - j) <= 1) continue;
                    
                    if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {
                        const intersectionPoint = getIntersectionPoint(
                            path[i], path[i + 1], 
                            path[j], path[j + 1]
                        );
                        intersections.push({ 
                            index1: i, 
                            index2: j,
                            point: intersectionPoint
                        });
                    }
                }
            }
            
            if (intersections.length === 0) {
                return { intersects: false };
            } else if (intersections.length === 1) {
                return { 
                    intersects: true, 
                    first: intersections[0],
                    last: intersections[0]
                };
            } else {
                // 複数ある場合
                // 始点に最も近い交差点 = index1が最小
                const first = intersections.reduce((min, curr) => 
                    curr.index1 < min.index1 ? curr : min
                );
                // 終点に最も近い交差点 = index2が最大
                const last = intersections.reduce((max, curr) => 
                    curr.index2 > max.index2 ? curr : max
                );
                
                return { 
                    intersects: true, 
                    first: first,
                    last: last
                };
            }
        }

        function endDrawing(e) {
            if (!isDrawing) return;
            e.preventDefault();
            isDrawing = false;
            
            if (currentPath.length > MIN_PATH_LENGTH) {
                const startPoint = currentPath[0];
                const endPoint = currentPath[currentPath.length - 1];
                const distance = Math.hypot(endPoint.x - startPoint.x, endPoint.y - startPoint.y);
                
                // 始点と終点が近い場合のみ閉じる（交差は描画中に処理済み）
                if (distance < CLOSE_THRESHOLD) {
                    currentPath.push(startPoint); // 始点に戻る
                    countEnclosedStones();
                } else {
                    // 閉じていない場合はエラー
                    currentPath = [];
                    updateResultDisplay('線が閉じませんでした。もう一度試してください');
                    redraw();
                }
            } else {
                currentPath = [];
                updateResultDisplay('線が短すぎます。もう一度試してください');
                redraw();
            }
        }

        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                
                const intersect = ((yi > point.y) !== (yj > point.y))
                    && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function countEnclosedStones() {
            const enclosedStones = stones.filter(stone => isPointInPolygon(stone, currentPath));
            const count = enclosedStones.length;
            
            // 石が1つも囲まれていない場合は無効
            if (count === 0) {
                currentPath = [];
                currentRoundResult = null;
                updateResultDisplay('石が囲まれていません。もう一度試してください');
                redraw();
                return;
            }
            
            const parity = count % 2 === 0 ? 2 : 1;
            
            currentRoundResult = {
                path: [...currentPath],
                count: count,
                parity: parity,
                enclosedStones: enclosedStones
            };
            
            completedRounds.push(parity);
            updateProgress();
            
            const parityText = parity === 2 ? '偶数' : '奇数';
            updateResultDisplay(`<span class="result-number">${count}</span>個の石を囲みました（${parityText}）`);
            
            redraw();
            
            // 4回完了したらシンボル表示
            if (completedRounds.length === 4) {
                setTimeout(() => {
                    showSymbolDialog();
                }, 1500);
            } else {
                setTimeout(() => {
                    currentPath = [];
                    currentRoundResult = null;
                    updateResultDisplay('次の領域を囲んでください');
                    redraw();
                }, 2000);
            }
        }

        function updateProgress() {
            document.getElementById('round-count').textContent = completedRounds.length;
            for (let i = 0; i < 4; i++) {
                const dot = document.getElementById(`progress-${i}`);
                if (i < completedRounds.length) {
                    dot.classList.add('completed');
                } else {
                    dot.classList.remove('completed');
                }
            }
        }

        function updateResultDisplay(html) {
            document.getElementById('result-text').innerHTML = html;
        }

        function showSymbolDialog() {
            const pattern = completedRounds.join('');
            let symbol = geomancySymbols[pattern];
            if (!symbol) {
                const keys = Object.keys(geomancySymbols);
                symbol = geomancySymbols[keys[0]];
            }
            
            const img = new Image();
            img.onload = () => {
                document.getElementById('symbol-image').src = `${pattern}.png`;
                document.getElementById('symbol-name').textContent = symbol.name;
                document.getElementById('symbol-yesno').textContent = `Yes/No: ${symbol.yesno}`;
                document.getElementById('symbol-fortune').textContent = `吉凶: ${symbol.fortune}`;
                document.getElementById('symbol-meaning').textContent = symbol.meaning;
                
                document.getElementById('symbolDialog').classList.add('show');
            };
            img.src = `${pattern}.png`;
        }

        function closeSymbolDialog() {
            document.getElementById('symbolDialog').classList.remove('show');
            setTimeout(() => {
                resetGame();
            }, 300);
        }

        function resetGame() {
            completedRounds = [];
            currentPath = [];
            currentRoundResult = null;
            updateProgress();
            updateResultDisplay('石を囲んで線を閉じてください');
            initStones();
            redraw();
        }

        // イベントリスナー
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', endDrawing);
        canvas.addEventListener('mouseleave', endDrawing);

        canvas.addEventListener('touchstart', startDrawing, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('touchend', endDrawing, { passive: false });

        window.addEventListener('resize', resizeCanvas);

        // 初期化
        document.addEventListener('DOMContentLoaded', function() {
            if ('scrollRestoration' in history) {
                history.scrollRestoration = 'manual';
            }
            window.scrollTo(0, 0);
            
            resizeCanvas();
            initStones();
            redraw();
        });
    </script>
</body>
</html>
